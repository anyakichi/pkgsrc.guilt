Ambiguous width characters support for tmux
diff --git a/patches/misc/tmux/utf8.c.patch b/patches/misc/tmux/utf8.c.patch
new file mode 100644
index 000000000..0e04df6c5
--- /dev/null
+++ b/patches/misc/tmux/utf8.c.patch
@@ -0,0 +1,284 @@
+--- utf8.c.orig	2017-09-10 17:03:16.000000000 +0900
++++ utf8.c	2018-08-12 00:00:23.000000000 +0900
+@@ -27,6 +27,272 @@
+ 
+ static int	utf8_width(wchar_t);
+ 
++#define AMBIWIDTH	2
++
++#ifdef AMBIWIDTH
++struct ambiwidth_entry {
++	wchar_t first;
++	wchar_t last;
++ };
++ 
++/* Ambiguous character's width */
++int ambiwidth = AMBIWIDTH;
++
++struct ambiwidth_entry ambiwidth_table[] = {
++	{ 0x0000a1, 0x0000a1 },
++	{ 0x0000a4, 0x0000a4 },
++	{ 0x0000a7, 0x0000a8 },
++	{ 0x0000aa, 0x0000aa },
++	{ 0x0000ad, 0x0000ae },
++	{ 0x0000b0, 0x0000b4 },
++	{ 0x0000b6, 0x0000ba },
++	{ 0x0000bc, 0x0000bf },
++	{ 0x0000c6, 0x0000c6 },
++	{ 0x0000d0, 0x0000d0 },
++	{ 0x0000d7, 0x0000d8 },
++	{ 0x0000de, 0x0000e1 },
++	{ 0x0000e6, 0x0000e6 },
++	{ 0x0000e8, 0x0000ea },
++	{ 0x0000ec, 0x0000ed },
++	{ 0x0000f0, 0x0000f0 },
++	{ 0x0000f2, 0x0000f3 },
++	{ 0x0000f7, 0x0000fa },
++	{ 0x0000fc, 0x0000fc },
++	{ 0x0000fe, 0x0000fe },
++	{ 0x000101, 0x000101 },
++	{ 0x000111, 0x000111 },
++	{ 0x000113, 0x000113 },
++	{ 0x00011b, 0x00011b },
++	{ 0x000126, 0x000127 },
++	{ 0x00012b, 0x00012b },
++	{ 0x000131, 0x000133 },
++	{ 0x000138, 0x000138 },
++	{ 0x00013f, 0x000142 },
++	{ 0x000144, 0x000144 },
++	{ 0x000148, 0x00014b },
++	{ 0x00014d, 0x00014d },
++	{ 0x000152, 0x000153 },
++	{ 0x000166, 0x000167 },
++	{ 0x00016b, 0x00016b },
++	{ 0x0001ce, 0x0001ce },
++	{ 0x0001d0, 0x0001d0 },
++	{ 0x0001d2, 0x0001d2 },
++	{ 0x0001d4, 0x0001d4 },
++	{ 0x0001d6, 0x0001d6 },
++	{ 0x0001d8, 0x0001d8 },
++	{ 0x0001da, 0x0001da },
++	{ 0x0001dc, 0x0001dc },
++	{ 0x000251, 0x000251 },
++	{ 0x000261, 0x000261 },
++	{ 0x0002c4, 0x0002c4 },
++	{ 0x0002c7, 0x0002c7 },
++	{ 0x0002c9, 0x0002cb },
++	{ 0x0002cd, 0x0002cd },
++	{ 0x0002d0, 0x0002d0 },
++	{ 0x0002d8, 0x0002db },
++	{ 0x0002dd, 0x0002dd },
++	{ 0x0002df, 0x0002df },
++	{ 0x000300, 0x00036f },
++	{ 0x000391, 0x0003a1 },
++	{ 0x0003a3, 0x0003a9 },
++	{ 0x0003b1, 0x0003c1 },
++	{ 0x0003c3, 0x0003c9 },
++	{ 0x000401, 0x000401 },
++	{ 0x000410, 0x00044f },
++	{ 0x000451, 0x000451 },
++	{ 0x002010, 0x002010 },
++	{ 0x002013, 0x002016 },
++	{ 0x002018, 0x002019 },
++	{ 0x00201c, 0x00201d },
++	{ 0x002020, 0x002022 },
++	{ 0x002024, 0x002027 },
++	{ 0x002030, 0x002030 },
++	{ 0x002032, 0x002033 },
++	{ 0x002035, 0x002035 },
++	{ 0x00203b, 0x00203b },
++	{ 0x00203e, 0x00203e },
++	{ 0x002074, 0x002074 },
++	{ 0x00207f, 0x00207f },
++	{ 0x002081, 0x002084 },
++	{ 0x0020ac, 0x0020ac },
++	{ 0x002103, 0x002103 },
++	{ 0x002105, 0x002105 },
++	{ 0x002109, 0x002109 },
++	{ 0x002113, 0x002113 },
++	{ 0x002116, 0x002116 },
++	{ 0x002121, 0x002122 },
++	{ 0x002126, 0x002126 },
++	{ 0x00212b, 0x00212b },
++	{ 0x002153, 0x002154 },
++	{ 0x00215b, 0x00215e },
++	{ 0x002160, 0x00216b },
++	{ 0x002170, 0x002179 },
++	{ 0x002189, 0x002189 },
++	{ 0x002190, 0x002199 },
++	{ 0x0021b8, 0x0021b9 },
++	{ 0x0021d2, 0x0021d2 },
++	{ 0x0021d4, 0x0021d4 },
++	{ 0x0021e7, 0x0021e7 },
++	{ 0x002200, 0x002200 },
++	{ 0x002202, 0x002203 },
++	{ 0x002207, 0x002208 },
++	{ 0x00220b, 0x00220b },
++	{ 0x00220f, 0x00220f },
++	{ 0x002211, 0x002211 },
++	{ 0x002215, 0x002215 },
++	{ 0x00221a, 0x00221a },
++	{ 0x00221d, 0x002220 },
++	{ 0x002223, 0x002223 },
++	{ 0x002225, 0x002225 },
++	{ 0x002227, 0x00222c },
++	{ 0x00222e, 0x00222e },
++	{ 0x002234, 0x002237 },
++	{ 0x00223c, 0x00223d },
++	{ 0x002248, 0x002248 },
++	{ 0x00224c, 0x00224c },
++	{ 0x002252, 0x002252 },
++	{ 0x002260, 0x002261 },
++	{ 0x002264, 0x002267 },
++	{ 0x00226a, 0x00226b },
++	{ 0x00226e, 0x00226f },
++	{ 0x002282, 0x002283 },
++	{ 0x002286, 0x002287 },
++	{ 0x002295, 0x002295 },
++	{ 0x002299, 0x002299 },
++	{ 0x0022a5, 0x0022a5 },
++	{ 0x0022bf, 0x0022bf },
++	{ 0x002312, 0x002312 },
++	{ 0x002460, 0x0024e9 },
++	{ 0x0024eb, 0x0024ff },
++#if 0
++	/* Skip linedraw characters defined by urxvt */
++	{ 0x002500, 0x00254b },
++	{ 0x002550, 0x002573 },
++	{ 0x002580, 0x00258f },
++	{ 0x002592, 0x002595 },
++#endif
++	{ 0x0025a0, 0x0025a1 },
++	{ 0x0025a3, 0x0025a9 },
++	{ 0x0025b2, 0x0025b3 },
++	{ 0x0025b6, 0x0025b7 },
++	{ 0x0025bc, 0x0025bd },
++	{ 0x0025c0, 0x0025c1 },
++	{ 0x0025c6, 0x0025c8 },
++	{ 0x0025cb, 0x0025cb },
++	{ 0x0025ce, 0x0025d1 },
++	{ 0x0025e2, 0x0025e5 },
++	{ 0x0025ef, 0x0025ef },
++	{ 0x002605, 0x002606 },
++	{ 0x002609, 0x002609 },
++	{ 0x00260e, 0x00260f },
++	{ 0x002614, 0x002615 },
++	{ 0x00261c, 0x00261c },
++	{ 0x00261e, 0x00261e },
++	{ 0x002640, 0x002640 },
++	{ 0x002642, 0x002642 },
++	{ 0x002660, 0x002661 },
++	{ 0x002663, 0x002665 },
++	{ 0x002667, 0x00266a },
++	{ 0x00266c, 0x00266d },
++	{ 0x00266f, 0x00266f },
++	{ 0x00269e, 0x00269f },
++	{ 0x0026be, 0x0026bf },
++	{ 0x0026c4, 0x0026cd },
++	{ 0x0026cf, 0x0026e1 },
++	{ 0x0026e3, 0x0026e3 },
++	{ 0x0026e8, 0x0026ff },
++	{ 0x00273d, 0x00273d },
++	{ 0x002757, 0x002757 },
++	{ 0x002776, 0x00277f },
++	{ 0x002b55, 0x002b59 },
++	{ 0x003248, 0x00324f },
++	{ 0x00e000, 0x00f8ff },
++	{ 0x00fe00, 0x00fe0f },
++	{ 0x00fffd, 0x00fffd },
++	{ 0x01f100, 0x01f10a },
++	{ 0x01f110, 0x01f12d },
++	{ 0x01f130, 0x01f169 },
++	{ 0x01f170, 0x01f19a },
++	{ 0x0e0100, 0x0e01ef },
++	{ 0x0f0000, 0x0ffffd },
++	{ 0x100000, 0x10fffd },
++};
++
++static int
++comp(const void *vkey, const void *vent)
++{
++	wchar_t key = *(wchar_t *)vkey;
++	const struct ambiwidth_entry *ent =
++	    (const struct ambiwidth_entry *)vent;
++
++	if (key < ent->first)
++		return -1;
++	else if (key > ent->last)
++		return 1;
++	else
++		return 0;
++}
++#endif
++
++static int
++my_wcwidth(wchar_t wc)
++{
++	struct ambiwidth_entry *item;
++	int width;
++
++	/* C0 control codes */
++	if (wc == L'\0')
++		return 0;
++	if (wc < 0x20)
++		return -1;
++	/* check 0x20-0x7e here for speed */
++	if (wc < 0x7f)
++		return 1;
++	/* C1 control codes */
++	if (wc < 0xa0)
++		return -1;
++
++#ifdef __APPLE__
++	if (0x03099 <= wc && wc <= 0x0309a)
++		return 1;
++#endif
++
++	width = wcwidth(wc);
++
++	if (width != 1)
++		return width;
++
++#ifdef AMBIWIDTH
++	item = (struct ambiwidth_entry *)
++	    bsearch(&wc, (const void *)ambiwidth_table,
++		    sizeof(ambiwidth_table) / sizeof(ambiwidth_table[0]),
++		    sizeof(ambiwidth_table[0]), comp);
++
++	if (item != NULL)
++		return 2;
++#endif
++
++	return 1;
++}
++
++int
++my_wcswidth(const wchar_t *ws, size_t wn)
++{
++	int w, width;
++
++	width = 0;
++	while (wn > 0 && *ws != L'\0') {
++		w = my_wcwidth(*ws);
++		if (w < 0)
++			return -1;
++		width += w;
++		ws++;
++		wn--;
++	}
++
++	return width;
++}
++
+ /* Set a single character. */
+ void
+ utf8_set(struct utf8_data *ud, u_char ch)
+@@ -112,7 +378,7 @@
+ #ifdef HAVE_UTF8PROC
+ 	width = utf8proc_wcwidth(wc);
+ #else
+-	width = wcwidth(wc);
++	width = my_wcwidth(wc);
+ #endif
+ 	if (width < 0 || width > 0xff) {
+ 		log_debug("Unicode %04lx, wcwidth() %d", (long)wc, width);

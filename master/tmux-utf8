# HG changeset patch
# Parent d3307f1ec7ef1ec94bdc0d05fd0ab136d2b82398
# Parent  086fd2fbb679a49ce27f5e6a81d336ebbbecb0aa
aa

diff --git a/patches/misc/tmux/no-utf8-acs.patch b/patches/misc/tmux/no-utf8-acs.patch
new file mode 100644
--- /dev/null
+++ b/patches/misc/tmux/no-utf8-acs.patch
@@ -0,0 +1,50 @@
+--- server-client.c.orig	2015-09-27 18:42:08.000000000 +0900
++++ server-client.c	2015-10-24 13:48:25.795601674 +0900
+@@ -1235,10 +1235,14 @@
+ 		return;
+ 	}
+ 	if (c->flags & CLIENT_UTF8)
+-		c->tty.flags |= TTY_UTF8;
++		c->tty.flags |= TTY_UTF8 | TTY_UTF8_ACS;
+ 	if (c->flags & CLIENT_256COLOURS)
+ 		c->tty.term_flags |= TERM_256COLOURS;
+ 
++	char *env = getenv("TMUX_NO_UTF8_ACS");
++	if (env && strcmp("0", env) != 0)
++		c->tty.flags &= ~TTY_UTF8_ACS;
++
+ 	tty_resize(&c->tty);
+ 
+ 	if (!(c->flags & CLIENT_CONTROL))
+--- tmux.h.orig	2015-09-27 18:51:49.000000000 +0900
++++ tmux.h	2015-10-24 13:26:39.745796432 +0900
+@@ -1118,6 +1118,7 @@
+ #define TTY_STARTED 0x10
+ #define TTY_OPENED 0x20
+ #define TTY_FOCUS 0x40
++#define TTY_UTF8_ACS 0x8000
+ 	int		 flags;
+ 
+ 	int		 term_flags;
+--- tty-acs.c.orig	2014-11-21 05:44:57.000000000 +0900
++++ tty-acs.c	2015-10-22 21:23:38.934933019 +0900
+@@ -81,7 +81,7 @@
+ 	struct tty_acs_entry *entry;
+ 
+ 	/* If not a UTF-8 terminal, use the ACS set. */
+-	if (tty != NULL && !(tty->flags & TTY_UTF8)) {
++	if (tty != NULL && !(tty->flags & TTY_UTF8_ACS)) {
+ 		if (tty->term->acs[ch][0] == '\0')
+ 			return (NULL);
+ 		return (&tty->term->acs[ch][0]);
+--- tty.c.orig	2015-09-27 18:51:49.000000000 +0900
++++ tty.c	2015-10-24 13:40:22.733122271 +0900
+@@ -54,7 +54,7 @@
+ void	tty_default_colours(struct grid_cell *, const struct window_pane *);
+ 
+ #define tty_use_acs(tty) \
+-	(tty_term_has((tty)->term, TTYC_ACSC) && !((tty)->flags & TTY_UTF8))
++	(tty_term_has((tty)->term, TTYC_ACSC) && !((tty)->flags & TTY_UTF8_ACS))
+ 
+ #define tty_pane_full_width(tty, ctx) \
+ 	((ctx)->xoff == 0 && screen_size_x((ctx)->wp->screen) >= (tty)->sx)
diff --git a/patches/misc/tmux/wcwidth.patch b/patches/misc/tmux/wcwidth.patch
new file mode 100644
--- /dev/null
+++ b/patches/misc/tmux/wcwidth.patch
@@ -0,0 +1,280 @@
+--- utf8.c.orig	2016-03-03 03:29:06.000000000 +0900
++++ utf8.c	2016-08-08 11:51:35.000000000 +0900
+@@ -26,6 +26,268 @@
+ 
+ static int	utf8_width(wchar_t);
+ 
++#define AMBIWIDTH	2
++
++#ifdef AMBIWIDTH
++struct ambiwidth_entry {
++	wchar_t first;
++	wchar_t last;
++ };
++ 
++/* Ambiguous character's width */
++int ambiwidth = AMBIWIDTH;
++
++struct ambiwidth_entry ambiwidth_table[] = {
++	{ 0x0000a1, 0x0000a1 },
++	{ 0x0000a4, 0x0000a4 },
++	{ 0x0000a7, 0x0000a8 },
++	{ 0x0000aa, 0x0000aa },
++	{ 0x0000ad, 0x0000ae },
++	{ 0x0000b0, 0x0000b4 },
++	{ 0x0000b6, 0x0000ba },
++	{ 0x0000bc, 0x0000bf },
++	{ 0x0000c6, 0x0000c6 },
++	{ 0x0000d0, 0x0000d0 },
++	{ 0x0000d7, 0x0000d8 },
++	{ 0x0000de, 0x0000e1 },
++	{ 0x0000e6, 0x0000e6 },
++	{ 0x0000e8, 0x0000ea },
++	{ 0x0000ec, 0x0000ed },
++	{ 0x0000f0, 0x0000f0 },
++	{ 0x0000f2, 0x0000f3 },
++	{ 0x0000f7, 0x0000fa },
++	{ 0x0000fc, 0x0000fc },
++	{ 0x0000fe, 0x0000fe },
++	{ 0x000101, 0x000101 },
++	{ 0x000111, 0x000111 },
++	{ 0x000113, 0x000113 },
++	{ 0x00011b, 0x00011b },
++	{ 0x000126, 0x000127 },
++	{ 0x00012b, 0x00012b },
++	{ 0x000131, 0x000133 },
++	{ 0x000138, 0x000138 },
++	{ 0x00013f, 0x000142 },
++	{ 0x000144, 0x000144 },
++	{ 0x000148, 0x00014b },
++	{ 0x00014d, 0x00014d },
++	{ 0x000152, 0x000153 },
++	{ 0x000166, 0x000167 },
++	{ 0x00016b, 0x00016b },
++	{ 0x0001ce, 0x0001ce },
++	{ 0x0001d0, 0x0001d0 },
++	{ 0x0001d2, 0x0001d2 },
++	{ 0x0001d4, 0x0001d4 },
++	{ 0x0001d6, 0x0001d6 },
++	{ 0x0001d8, 0x0001d8 },
++	{ 0x0001da, 0x0001da },
++	{ 0x0001dc, 0x0001dc },
++	{ 0x000251, 0x000251 },
++	{ 0x000261, 0x000261 },
++	{ 0x0002c4, 0x0002c4 },
++	{ 0x0002c7, 0x0002c7 },
++	{ 0x0002c9, 0x0002cb },
++	{ 0x0002cd, 0x0002cd },
++	{ 0x0002d0, 0x0002d0 },
++	{ 0x0002d8, 0x0002db },
++	{ 0x0002dd, 0x0002dd },
++	{ 0x0002df, 0x0002df },
++	{ 0x000300, 0x00036f },
++	{ 0x000391, 0x0003a1 },
++	{ 0x0003a3, 0x0003a9 },
++	{ 0x0003b1, 0x0003c1 },
++	{ 0x0003c3, 0x0003c9 },
++	{ 0x000401, 0x000401 },
++	{ 0x000410, 0x00044f },
++	{ 0x000451, 0x000451 },
++	{ 0x002010, 0x002010 },
++	{ 0x002013, 0x002016 },
++	{ 0x002018, 0x002019 },
++	{ 0x00201c, 0x00201d },
++	{ 0x002020, 0x002022 },
++	{ 0x002024, 0x002027 },
++	{ 0x002030, 0x002030 },
++	{ 0x002032, 0x002033 },
++	{ 0x002035, 0x002035 },
++	{ 0x00203b, 0x00203b },
++	{ 0x00203e, 0x00203e },
++	{ 0x002074, 0x002074 },
++	{ 0x00207f, 0x00207f },
++	{ 0x002081, 0x002084 },
++	{ 0x0020ac, 0x0020ac },
++	{ 0x002103, 0x002103 },
++	{ 0x002105, 0x002105 },
++	{ 0x002109, 0x002109 },
++	{ 0x002113, 0x002113 },
++	{ 0x002116, 0x002116 },
++	{ 0x002121, 0x002122 },
++	{ 0x002126, 0x002126 },
++	{ 0x00212b, 0x00212b },
++	{ 0x002153, 0x002154 },
++	{ 0x00215b, 0x00215e },
++	{ 0x002160, 0x00216b },
++	{ 0x002170, 0x002179 },
++	{ 0x002189, 0x002189 },
++	{ 0x002190, 0x002199 },
++	{ 0x0021b8, 0x0021b9 },
++	{ 0x0021d2, 0x0021d2 },
++	{ 0x0021d4, 0x0021d4 },
++	{ 0x0021e7, 0x0021e7 },
++	{ 0x002200, 0x002200 },
++	{ 0x002202, 0x002203 },
++	{ 0x002207, 0x002208 },
++	{ 0x00220b, 0x00220b },
++	{ 0x00220f, 0x00220f },
++	{ 0x002211, 0x002211 },
++	{ 0x002215, 0x002215 },
++	{ 0x00221a, 0x00221a },
++	{ 0x00221d, 0x002220 },
++	{ 0x002223, 0x002223 },
++	{ 0x002225, 0x002225 },
++	{ 0x002227, 0x00222c },
++	{ 0x00222e, 0x00222e },
++	{ 0x002234, 0x002237 },
++	{ 0x00223c, 0x00223d },
++	{ 0x002248, 0x002248 },
++	{ 0x00224c, 0x00224c },
++	{ 0x002252, 0x002252 },
++	{ 0x002260, 0x002261 },
++	{ 0x002264, 0x002267 },
++	{ 0x00226a, 0x00226b },
++	{ 0x00226e, 0x00226f },
++	{ 0x002282, 0x002283 },
++	{ 0x002286, 0x002287 },
++	{ 0x002295, 0x002295 },
++	{ 0x002299, 0x002299 },
++	{ 0x0022a5, 0x0022a5 },
++	{ 0x0022bf, 0x0022bf },
++	{ 0x002312, 0x002312 },
++	{ 0x002460, 0x0024e9 },
++	{ 0x0024eb, 0x00254b },
++	{ 0x002550, 0x002573 },
++	{ 0x002580, 0x00258f },
++	{ 0x002592, 0x002595 },
++	{ 0x0025a0, 0x0025a1 },
++	{ 0x0025a3, 0x0025a9 },
++	{ 0x0025b2, 0x0025b3 },
++	{ 0x0025b6, 0x0025b7 },
++	{ 0x0025bc, 0x0025bd },
++	{ 0x0025c0, 0x0025c1 },
++	{ 0x0025c6, 0x0025c8 },
++	{ 0x0025cb, 0x0025cb },
++	{ 0x0025ce, 0x0025d1 },
++	{ 0x0025e2, 0x0025e5 },
++	{ 0x0025ef, 0x0025ef },
++	{ 0x002605, 0x002606 },
++	{ 0x002609, 0x002609 },
++	{ 0x00260e, 0x00260f },
++	{ 0x002614, 0x002615 },
++	{ 0x00261c, 0x00261c },
++	{ 0x00261e, 0x00261e },
++	{ 0x002640, 0x002640 },
++	{ 0x002642, 0x002642 },
++	{ 0x002660, 0x002661 },
++	{ 0x002663, 0x002665 },
++	{ 0x002667, 0x00266a },
++	{ 0x00266c, 0x00266d },
++	{ 0x00266f, 0x00266f },
++	{ 0x00269e, 0x00269f },
++	{ 0x0026be, 0x0026bf },
++	{ 0x0026c4, 0x0026cd },
++	{ 0x0026cf, 0x0026e1 },
++	{ 0x0026e3, 0x0026e3 },
++	{ 0x0026e8, 0x0026ff },
++	{ 0x00273d, 0x00273d },
++	{ 0x002757, 0x002757 },
++	{ 0x002776, 0x00277f },
++	{ 0x002b55, 0x002b59 },
++	{ 0x003248, 0x00324f },
++	{ 0x00e000, 0x00f8ff },
++	{ 0x00fe00, 0x00fe0f },
++	{ 0x00fffd, 0x00fffd },
++	{ 0x01f100, 0x01f10a },
++	{ 0x01f110, 0x01f12d },
++	{ 0x01f130, 0x01f169 },
++	{ 0x01f170, 0x01f19a },
++	{ 0x0e0100, 0x0e01ef },
++	{ 0x0f0000, 0x0ffffd },
++	{ 0x100000, 0x10fffd },
++};
++
++static int
++comp(const void *vkey, const void *vent)
++{
++	wchar_t key = *(wchar_t *)vkey;
++	const struct ambiwidth_entry *ent =
++	    (const struct ambiwidth_entry *)vent;
++
++	if (key < ent->first)
++		return -1;
++	else if (key > ent->last)
++		return 1;
++	else
++		return 0;
++}
++#endif
++
++static int
++my_wcwidth(wchar_t wc)
++{
++	struct ambiwidth_entry *item;
++	int width;
++
++	/* C0 control codes */
++	if (wc == L'\0')
++		return 0;
++	if (wc < 0x20)
++		return -1;
++	/* check 0x20-0x7e here for speed */
++	if (wc < 0x7f)
++		return 1;
++	/* C1 control codes */
++	if (wc < 0xa0)
++		return -1;
++
++#ifdef __APPLE__
++	if (0x03099 <= wc && wc <= 0x0309a)
++		return 1;
++#endif
++
++	width = wcwidth(wc);
++
++	if (width != 1)
++		return width;
++
++#ifdef AMBIWIDTH
++	item = (struct ambiwidth_entry *)
++	    bsearch(&wc, (const void *)ambiwidth_table,
++		    sizeof(ambiwidth_table) / sizeof(ambiwidth_table[0]),
++		    sizeof(ambiwidth_table[0]), comp);
++
++	if (item != NULL)
++		return 2;
++#endif
++
++	return 1;
++}
++
++int
++my_wcswidth(const wchar_t *ws, size_t wn)
++{
++	int w, width;
++
++	width = 0;
++	while (wn > 0 && *ws != L'\0') {
++		w = my_wcwidth(*ws);
++		if (w < 0)
++			return -1;
++		width += w;
++		ws++;
++		wn--;
++	}
++
++	return width;
++}
++
+ /* Set a single character. */
+ void
+ utf8_set(struct utf8_data *ud, u_char ch)
+@@ -114,7 +376,7 @@
+ {
+ 	int	width;
+ 
+-	width = wcwidth(wc);
++	width = my_wcwidth(wc);
+ 	if (width < 0 || width > 0xff)
+ 		return (-1);
+ 	return (width);
